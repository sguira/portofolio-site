# -*- coding: utf-8 -*-
"""EstimationDeDenistéNonParamétrique.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T_qayuYAFBPFJSztBr02PuGJUsXdi58O

#  Estimation non parametrique de la densité
"""

import pandas as pd 
data = pd.read_csv("/content/sample_data/breast-cancer.csv")
data=data["texture_mean"]

"""Dans le jeu de données sur le cancer du sein, la caractéristique "texture_mean" représente la valeur moyenne des niveaux d'intensité en niveaux de gris des pixels dans l'image. C'est l'une des caractéristiques incluses dans le jeu de données pour la tâche de classification du cancer du sein.

## Densité parametrique
"""

minimum_x=data.min()
maximum_x=data.max()
std_x=data.std()
q1_x=data.quantile(0.25)
q2_x=data.quantile(0.50)
q3_x=data.quantile(0.75)
mean_x=data.mean()

"""Dans cet exemple, nous utilisons une distribution normale (norm) comme exemple de distribution paramétrique. Vous pouvez remplacer norm par une autre distribution appropriée en fonction de vos données.

Nous utilisons norm.fit(data) pour estimer les paramètres (mu pour la moyenne et sigma pour l'écart-type) de la distribution normale à partir de la série de données

Nous calculons ensuite la densité de la distribution normale en utilisant norm.pdf(x, mu, sigma) pour obtenir les valeurs de densité correspondantes à chaque point de x.

Enfin, nous utilisons plt.plot(x, density) pour tracer la densité paramétrique sur le graphique.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm  # Exemple avec une distribution normale


# Estimer les paramètres de la distribution
mu, sigma = norm.fit(data.values)

# Générer une plage de valeurs x
x = np.linspace(minimum_x, maximum_x, len(data.values))

# Calculer la densité de la distribution paramétrique
density = norm.pdf(x, mu, sigma)

# Tracer la densité
plt.plot(x, density)

# Afficher le graphique
plt.show()

"""## Estimation par histogram"""

import numpy as np
from sklearn.neighbors import KernelDensity

# Tracer la densité
data.plot(kind='density')

# Tracer la densité avec des limites d'axe x personnalisées
ax = data.plot(kind='density')

ax.set_xlim(minimum_x, maximum_x)  # Définir les limites de l'axe x

# Afficher le graphique
plt.show()

"""## I Estimation par noyaux"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import stats


# Paramètres de la densité
x_values = np.linspace(minimum_x, maximum_x, len(data))  # Plage de valeurs pour l'axe x

# Noyaux disponibles dans SciPy
kernels = {
    'epanechnikov': 0.2,
    'rectangular': 0.2,
    'triangular': 0.2,
    'gaussian': None,
    'polynomial': 0.2
}

# Affichage des estimations de densité

#plt.figure(figsize=(10, 6))
#plt.hist(data, bins=30, density=True, alpha=0.5, label='Histogramme')

# Affichage des estimations de densité
plt.figure(figsize=(10, 6))
plt.hist(data, bins=30, density=True, alpha=0.5, label='Histogramme')

for kernel_name, bw_method in kernels.items():
    kernel = stats.gaussian_kde(data, bw_method=bw_method)
    density_estimate = kernel.evaluate(x_values)
    plt.plot(x_values, density_estimate, label=kernel_name)

plt.xlabel('Valeurs de X')
plt.ylabel('Densité')
plt.title('Estimation de densité avec différents noyaux')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
# Paramètres de la densité
x_values = np.linspace(minimum_x, maximum_x, len(data))  # Plage de valeurs pour l'axe x

# Noyaux disponibles dans SciPy
kernels = {
    'epanechnikov': 0.2,
    'rectangular': 0.2,
    'triangular': 0.2,
    'gaussian': None,
    'polynomial': 0.2
}

# Création de la grille de graphes
fig, axs = plt.subplots(len(kernels), 1, figsize=(10, 12), sharex=True)

# Affichage des estimations de densité sur chaque graphe
for i, (kernel_name, bw_method) in enumerate(kernels.items()):
    kernel = stats.gaussian_kde(data, bw_method=bw_method)
    density_estimate = kernel.evaluate(x_values)

    axs[i].plot(x_values, density_estimate)
    axs[i].set_ylabel('Densité')
    axs[i].set_title(kernel_name)

# Paramètres de l'axe x commun
axs[-1].set_xlabel('Valeurs de X')

# Ajustement des espacements entre les graphes
plt.tight_layout()

# Affichage du graphique
plt.show()

# Calcul du nombre de lignes et de colonnes pour la grille
num_rows = len(kernels) // 2 + len(kernels) % 2
num_cols = 2

# Création de la grille de graphes
fig, axs = plt.subplots(num_rows, num_cols, figsize=(12, 6), sharex=True)

# Affichage des estimations de densité sur chaque graphe
for i, (kernel_name, bw_method) in enumerate(kernels.items()):
    row = i // num_cols
    col = i % num_cols

    kernel = stats.gaussian_kde(data, bw_method=bw_method)
    density_estimate = kernel.evaluate(x_values)

    ax = axs[row, col]
    ax.plot(x_values, density_estimate)
    ax.set_ylabel('Densité')
    ax.set_title(kernel_name)

# Suppression des axes vides
if len(kernels) % 2 != 0:
    fig.delaxes(axs[-1, -1])

# Paramètres de l'axe x commun
axs[-1, 0].set_xlabel('Valeurs de X')
axs[-1, 1].set_xlabel('Valeurs de X')

# Ajustement des espacements entre les graphes
plt.tight_layout()

# Affichage du graphique
plt.show()